// Copyright 2021 Alpha Lam <arufa.hc@gmail.com>.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// This program consumes a build_prof.icc file generated by ArgyllCMS
// and matrix and tone curves generated in build_prof.h to create a
// ICC profile.

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <lcms2.h>
#include <lcms2_plugin.h>
#include "build_prof.h"

#define COPYRIGHT "Copyright 2021, Alpha Lam (arufahc@gmail.com)."
#define MANUFACTURER "Alpha Lam (arufahc@gmail.com)"
#define DESCRIPTION "NegICC Matrix Ektar 100 Profile"

void error_handler(cmsContext context, cmsUInt32Number error, const char* text) {
  fprintf(stderr, "Error! Code: %d, msg: %s.\n", error, text);
}

// Returns a cLUT stage from a profile, e.g. one created by ArgyllCMS.
cmsStage* read_clut_stage(const char* input_profile) {
  // Read profile generated by ArgyllCMS and parse the 3 stages in A2B0 tag.
  cmsHPROFILE in_profile = cmsOpenProfileFromFile(input_profile, "r");
  cmsPipeline *pipeline = cmsReadTag(in_profile, cmsSigAToB0Tag);
  cmsStage *inputstage, *clutstage, *outputstage;
  if (!cmsPipelineCheckAndRetreiveStages(
                                         pipeline, 3,
                                         cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType,
                                         &inputstage, &clutstage, &outputstage)) {
    fprintf(stderr, "Error! Failed to load 3 stages from A2B0 tag in build_prof.icc.\n");
    return NULL;
  }

  // Copy the cLUT in the input profile by converting them to floats.
  _cmsStageCLutData* clut_data = (_cmsStageCLutData*)cmsStageData(clutstage);
  printf("cLUT has elements: %d\n", clut_data->nEntries);

  cmsFloat32Number* tablef = malloc(sizeof(cmsFloat32Number) * clut_data->nEntries);
  memset(tablef, 0, sizeof(cmsFloat32Number) * clut_data->nEntries);
  for (int i = 0; i < clut_data->nEntries; ++i)
    tablef[i] = clut_data->Tab.T[i] / 65535.0f;
  return cmsStageAllocCLutFloatGranular(NULL, clut_data->Params->nSamples, 3, 3, tablef);
}

void make_std_negative_profile() {

  cmsHPROFILE out_profile = cmsCreateRGBProfile(NULL, NULL, NULL);
  cmsSetProfileVersion(out_profile, 4.3);
  cmsSetPCS(out_profile, cmsSigXYZData);
  cmsSetDeviceClass(out_profile, cmsSigInputClass);

  cmsMLU* copyright = cmsMLUalloc(NULL, 1);
  cmsMLUsetASCII(copyright, "en", "US", COPYRIGHT);
  cmsWriteTag(out_profile, cmsSigCopyrightTag, copyright);
  cmsMLU* manufacturer = cmsMLUalloc(NULL, 1);
  cmsMLUsetASCII(manufacturer, "en", "US", MANUFACTURER);
  cmsWriteTag(out_profile, cmsSigDeviceMfgDescTag, manufacturer);
  cmsMLU* description = cmsMLUalloc(NULL, 1);
  cmsMLUsetASCII(description, "en", "US", DESCRIPTION);
  cmsWriteTag(out_profile, cmsSigProfileDescriptionTag, description);

  // White and black point.
  // cmsWriteTag(out_profile, cmsSigMediaWhitePointTag, (cmsCIEXYZ*)cmsReadTag(in_profile, cmsSigMediaWhitePointTag));
  // cmsWriteTag(out_profile, cmsSigMediaBlackPointTag, (cmsCIEXYZ*)cmsReadTag(in_profile, cmsSigMediaBlackPointTag));

  // Adds a fallback A2B0 tag which gives a black image in case D2B0 is not supported.
  cmsPipeline* black_pipeline = cmsPipelineAlloc(NULL, 3, 3);
  cmsUInt16Number black[256];
  memset(black, 0, sizeof(black));
  cmsToneCurve* black_curve[3];
  black_curve[0] = black_curve[1] = black_curve[2] = cmsBuildTabulatedToneCurve16(NULL, 256, black);
  cmsPipelineInsertStage(black_pipeline, cmsAT_BEGIN, cmsStageAllocToneCurves(NULL, 3, black_curve));

  int ret = cmsWriteTag(out_profile, cmsSigAToB0Tag, black_pipeline);
  if (!ret) {
    fprintf(stdout, "Failed to save A2B0 pipeline!\n");
  }

  cmsToneCurve* curvef[3];
  curvef[0] = cmsBuildTabulatedToneCurveFloat(NULL, sizeof(r_curve) / sizeof(float), r_curve);
  curvef[1] = cmsBuildTabulatedToneCurveFloat(NULL, sizeof(g_curve) / sizeof(float), g_curve);
  curvef[2] = cmsBuildTabulatedToneCurveFloat(NULL, sizeof(b_curve) / sizeof(float), b_curve);
  cmsPipeline* neg_pipeline = cmsPipelineAlloc(NULL, 3, 3);

  cmsPipelineInsertStage(neg_pipeline, cmsAT_END, cmsStageAllocMatrix(NULL, 3, 3, crosstalk_correction_mat, NULL));
  cmsPipelineInsertStage(neg_pipeline, cmsAT_END, cmsStageAllocToneCurves(NULL, 3, curvef)); // negative tone curves.
  cmsPipelineInsertStage(neg_pipeline, cmsAT_END, read_clut_stage("build_prof.icc"));

  // Commented out try using a matrix to convert from RGB to XYZ using linear regression.

// From dcraw images and computed by argyllcms.
  /*
double mat[] = 
{0.499288, 0.588059, 0.069591,
         0.293241, 0.936905, -0.033396,
         0.037895, 0.367030, 0.719375};
  */
// From c1 images and computed by argyllcms.
  double mat[] = {0.582536, 0.521643, 0.066786,
		  0.362451, 0.882864, -0.038254,
		  0.063813, 0.325665, 0.749723,
		  0, 0, 0};

// From c1 images and computed by weka.
  /*
  double mat[] = {
 0.60889666, 0.63277913, -0.03418621,
 0.43124504, 0.94003491, -0.12569812,
 0.15286638, 0.59404957, 0.45594718,
 -0.0210972022, -0.0181275504, -0.0450803296
};
  */
  cmsPipelineInsertStage(neg_pipeline, cmsAT_END, cmsStageAllocMatrix(NULL, 3, 3, mat, NULL));
  printf("New pipeline has stages: %d\n", cmsPipelineStageCount(neg_pipeline));

  ret = cmsWriteTag(out_profile, cmsSigDToB0Tag, neg_pipeline);
  if (!ret) {
    fprintf(stdout, "Failed to save D2B0 pipeline.\n");
  }
  cmsMD5computeID(out_profile);
  ret = cmsSaveProfileToFile(out_profile, "icc_out/std_negative.icc");
  if (!ret) {
    printf("Failed to save profile!\n");
  }
}

int main () {
  cmsSetLogErrorHandler(&error_handler);
  make_std_negative_profile();
  return 0;
}
